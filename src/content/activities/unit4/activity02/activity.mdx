import P5Sketch from '../../../../components/P5Sketch.astro';

#### Implementaci√≥n de la lista en enlazada

üéØ **Enunciado**: en la actividad anterior usaste una lista enlazada para 
organizar las diferentes partes, nodos, que componen a la serpiente. Usaste la 
implementaci√≥n de la lista enlazada que trae la biblioteca est√°ndar de C++. En 
esta actividad explorar√°s una implementaci√≥n de la lista enlazada. El objetivo 
de esto es que entiendas c√≥mo funciona la lista enlazada y c√≥mo se podr√≠a implementar.
Nota que digo c√≥mo se podr√≠a implementar, ya que no es la √∫nica forma de hacerlo.

- Lo primero que har√°s ser√° generar un nuevo proyecto con el generado 
de proyectos de openframeworks. Antes de hacer cualquier cosa, vas 
a compilar y ejecutar el proyecto para asegurarte de que todo 
funciona. Nota que ya no dir√© c√≥mo hacerlo, ya que lo has hecho 
anteriormente. Si no sabes c√≥mo hacerlo, revisa la actividad anterior. 
- Modifica el archivo ofApp.h as√≠:

``` cpp	
#pragma once

#include "ofMain.h"

class ofApp : public ofBaseApp {
public:
    void setup();
    void update();
    void draw();
    void keyPressed(int key);
};
```

- Ahora agrega, debajo de `#include "ofMain.h"`, la definici√≥n de la clase `Node`:

``` cpp
class Node {
    public:
        glm::vec2 position;
        Node* next;

        Node(glm::vec2 pos) : position(pos), next(nullptr) {}
}
```

Node es la clase que representa un nodo de la lista enlazada. En 
la aplicaci√≥n de la serpiente, cada nodo representa una parte de la serpiente. 
¬øRecuerdas la definici√≥n de la lista enlazada? Un nodo tiene un valor y un puntero al 
siguiente nodo. En este caso el valor es la posici√≥n del nodo y el puntero
es un puntero a otro nodo. La posici√≥n es un vector 2D, que representa la
posici√≥n del nodo en la pantalla. El puntero `next` es un puntero a otro
nodo. El constructor de la clase inicializa la posici√≥n del nodo y el puntero
`next` a `nullptr`. 

**Reflexiona en tu bit√°cora**: realiza un dibujo de c√≥mo se ver√≠a la lista enlazada
si tuviera 3 nodos. ¬øQu√© pasar√≠a luego si tuvi√©ramos 4 nodos?

- Ahora agrega la clase LinkedList:

``` cpp
class LinkedList {
public:
    Node* head;
    Node* tail;
    int size;

    LinkedList() : head(nullptr), tail(nullptr), size(0) {}

    ~LinkedList() {
        clear();
    }

    void push_back(glm::vec2 pos) {
        Node* newNode = new Node(pos);
        if (head == nullptr) {
            head = tail = newNode;
        }
        else {
            tail->next = newNode;
            tail = newNode;
        }
        size++;
    }

    void pop_back() {
        if (head == nullptr) return;

        if (head == tail) { // Si solo hay un elemento
            delete head;
            head = tail = nullptr;
        }
        else {
            Node* temp = head;
            while (temp->next != tail) {
                temp = temp->next;
            }
            delete tail;
            tail = temp;
            tail->next = nullptr;
        }
        size--;
    }

    void clear() {
        Node* current = head;
        while (current != nullptr) {
            Node* nextNode = current->next;
            delete current;
            current = nextNode;
        }
        head = tail = nullptr;
        size = 0;
    }
};
```
La clase `LinkedList` representa una lista enlazada. Tiene un puntero al 
primer nodo de la lista, un puntero al √∫ltimo nodo de la lista y un entero que
representa el tama√±o de la lista. 

``` cpp
public:
    Node* head;
    Node* tail;
    int size;
```

**Reflexiona en tu bit√°cora**: dibuja de nuevo la lista enlazada con 3 nodos. Ahora 
dibuja un objeto de la clase `LinkedList`. A donde apuntan los punteros `head` y `tail`? 
Qu√© valor tiene el entero `size`?

**Reflexiona en tu bit√°cora**: ¬øQu√© pasar√≠a si el objeto de la clase `LinkedList` 
no tuviera el puntero a head? ¬øPodr√≠as recorrer la lista? ¬øQu√© pasar√≠a si no tuviera el puntero a tail? 
¬øPodr√≠as agregar un nuevo nodo al final de la lista? ¬øQu√© pasar√≠a si no tuviera el entero size? 
¬øPodr√≠as saber cu√°ntos nodos hay en la lista? Por favor, reflexiona profundamente sobre estas preguntas. 
Las respuestas a estas preguntas son importantes para entender c√≥mo funciona la lista enlazada.

El constructor inicializa los punteros a `nullptr` y el tama√±o a 0. 
El destructor llama al m√©todo `clear`, que libera la memoria de todos los nodos de la lista. 

``` cpp	
LinkedList() : head(nullptr), tail(nullptr), size(0) {}

~LinkedList() {
    clear();
}
```

Te estar√°s preguntando, ¬øQu√© es eso del destructor? El destructor es un 
m√©todo especial que se llama cuando un objeto de la clase se destruye.
En este caso, el destructor se llama cuando la lista enlazada se destruye.

**Reflexiona en tu bit√°cora**: el destructor de la clase `LinkedList` tiene como 
prop√≥sito liberar la memoria que ocupa el objeto de la clase `LinkedList`. ¬øPor qu√© 
se necesario liberar la memoria que ocupa el objeto y adem√°s liberar la memoria de 
los nodos de la lista? ¬øQu√© pasar√≠a si no lo hicieras? 

**Reflexiona en tu bit√°cora**: el objeto de la clase `LinkedList` qu√© datos tiene? 
y ¬øCu√°l es la relaci√≥n con los nodos de la lista? En este punto te pedir√© que uses 
el depurador para ver la memoria y poder analizar las preguntas.

El destructor libera la memoria de todos los nodos de la lista. Esto es
importante porque si no lo haces, puedes tener fugas de memoria. Una fuga
de memoria es cuando la memoria que se ha reservado no se libera. Esto
puede causar que tu programa se quede sin memoria y se bloquee. Por eso 
es importante liberar la memoria de los nodos de la lista cuando ya no 
los necesitas. Esto debe hacerse de manera manual en C++, ya que no tienes 
un recolector de basura como en otros lenguajes de programaci√≥n, por ejemplo, 
C#.

**Reflexiona en tu bit√°cora**: cuando programas en C# no ten√≠as que liberar la 
memoria de los objetos. ¬øPor qu√© crees que en C++ es necesario liberar la memoria
de los objetos?

El m√©todo `push_back` agrega un nuevo nodo al final de la lista. Si la lista 
est√° vac√≠a, el nuevo nodo se convierte en el primer y √∫ltimo nodo de la lista. 
Si la lista no est√° vac√≠a, el nuevo nodo se agrega al final de la lista y el puntero `tail`
se actualiza. 

``` cpp	
void push_back(glm::vec2 pos) {
    Node* newNode = new Node(pos);
    if (head == nullptr) {
        head = tail = newNode;
    }
    else {
        tail->next = newNode;
        tail = newNode;
    }
    size++;
}
```

**Reflexiona en tu bit√°cora**: realiza varios dibujos donde muestres c√≥mo se 
ver√≠a el objeto de la clase `LinkedList` antes y despu√©s de agregar un nuevo nodo. 
Realiza este ejercicio cuando size sea 0, 1 y 2.

El m√©todo `pop_back` elimina el √∫ltimo nodo de la lista. Si
la lista est√° vac√≠a, no hace nada. Si la lista tiene un solo nodo, se
elimina el nodo y se actualizan los punteros `head` y `tail` a `nullptr`.
Si la lista tiene m√°s de un nodo, se recorre la lista hasta llegar al
pen√∫ltimo nodo, se elimina el √∫ltimo nodo y se actualiza el puntero `tail`
al pen√∫ltimo nodo. 

``` cpp	
void pop_back() {
    if (head == nullptr) return;

    if (head == tail) { // Si solo hay un elemento
        delete head;
        head = tail = nullptr;
    }
    else {
        Node* temp = head;
        while (temp->next != tail) {
            temp = temp->next;
        }
        delete tail;
        tail = temp;
        tail->next = nullptr;
    }
    size--;
}
```

**Reflexiona en tu bit√°cora**: realiza varios dibujos donde muestres c√≥mo se 
ver√≠a el objeto de la clase `LinkedList` antes y despu√©s de eliminar un nodo. 
Realiza este ejercicio cuando size sea 0, 1 y 2.

El m√©todo `clear` libera la memoria de todos los nodos
de la lista. Se recorre la lista y se elimina cada nodo. Al final, se
actualizan los punteros `head` y `tail` a `nullptr` y el tama√±o a 0.

``` cpp
void clear() {
    Node* current = head;
    while (current != nullptr) {
        Node* nextNode = current->next;
        delete current;
        current = nextNode;
    }
    head = tail = nullptr;
    size = 0;
}
```

**Reflexiona en tu bit√°cora**: realiza dibujos que muestren c√≥mo se ver√≠a el 
objeto de la clase `LinkedList` durante la ejecuci√≥n del m√©todo `clear`.

Ahora actualiza el archivo ofApp.cpp as√≠:

``` cpp
#include "ofApp.h"

//--------------------------------------------------------------
void ofApp::setup() {
    backgroundHue = 0;

    // Inicializa la serpiente con varios nodos en el centro
    for (int i = 0; i < 20; i++) {
        snake.push_back(glm::vec2(ofGetWidth() / 2, ofGetHeight() / 2));
    }
}

//--------------------------------------------------------------
void ofApp::update() {
    if (snake.head == nullptr) return;

    glm::vec2 target = glm::vec2(ofGetMouseX(), ofGetMouseY());
    float interpolationFactor = 0.2;

    Node* current = snake.head;
    while (current != nullptr) {
        current->position = glm::mix(glm::vec3(current->position, 0.0f), glm::vec3(target, 0.0f), interpolationFactor);
        target = current->position;
        current = current->next;
    }

    backgroundHue = fmod(backgroundHue + 0.1, 255);
}

//--------------------------------------------------------------
void ofApp::draw() {
    ofColor color1 = ofColor::fromHsb(backgroundHue, 150, 240);
    ofColor color2 = ofColor::fromHsb(fmod(backgroundHue + 128, 255), 150, 240);
    ofBackgroundGradient(color1, color2, OF_GRADIENT_LINEAR);

    if (snake.head == nullptr) return;

    ofMesh mesh;
    mesh.setMode(OF_PRIMITIVE_LINE_STRIP);
    Node* current = snake.head;
    int index = 0;

    while (current) {
        float hue = ofMap(index++, 0, snake.size - 1, 0, 255);
        mesh.addColor(ofColor::fromHsb(hue, 200, 255));
        mesh.addVertex(glm::vec3(current->position, 0.0f));
        current = current->next;
    }

    ofSetLineWidth(2);
    mesh.draw();

    // C√≠rculos con tama√±o y color variable
    current = snake.head;
    index = 0;
    ofNoFill();
    ofSetLineWidth(2);

    while (current) {
        float hue = ofMap(index, 0, snake.size - 1, 0, 255);
        ofSetColor(ofColor::fromHsb(hue, 220, 255));
        float radius = ofMap(index++, 0, snake.size - 1, 20, 5);
        ofDrawCircle(current->position.x, current->position.y, radius);
        current = current->next;
    }
}

//--------------------------------------------------------------
void ofApp::keyPressed(int key) {
    if (key == 'c') {
        snake.clear();
    }
    else if (key == 'a') {
        snake.push_back(glm::vec2(ofRandomWidth(), ofRandomHeight()));
    }
    else if (key == 'r') {
        snake.pop_back();
    }
    else if (key == 's') {
        ofSaveFrame();
    }
}
```

**Reflexiona en tu bit√°cora**: De manera general y sin entrar en detalles finos, 
¬øQu√© hace el m√©todo `setup`? ¬øQu√© hace el m√©todo `update`? ¬øQu√© hace el m√©todo `draw`? 
¬øQu√© hace el m√©todo `keyPressed`?

Analiza esta parte del c√≥digo:

```cpp
Node* current = snake.head;
while (current != nullptr) {
    current->position = glm::mix(glm::vec3(current->position, 0.0f), glm::vec3(target, 0.0f), interpolationFactor);
    target = current->position;
    current = current->next;
}
```
Para entender c√≥mo funciona mix, observa antes esta simulaci√≥n:

<P5Sketch 
  sketchUrl="/computacionales-2025-20/sketches/interpolation.js" 
  containerId="interpolation"
  styleClass="p5-container-interpolation"
/>

`glm::mix` te permitir√° interpolar entre dos vectores. En este caso, est√°s interpolando 
entre la posici√≥n actual del nodo y la posici√≥n del mouse. El tercer par√°metro es el factor 
de interpolaci√≥n, que va de 0 a 1. Un valor de 0 significa que el nodo no se mover√°, un valor 
de 1 significa que el nodo se mover√° completamente a la posici√≥n del mouse. Un valor de 0.5 
significa que el nodo se mover√° a la mitad entre su posici√≥n actual y la posici√≥n del mouse.

Finalmente, analiza la funci√≥n draw. En esta funci√≥n se dibuja la serpiente.

Si necesitas repasar el sistema HSB revisa esta simulaci√≥n:

<P5Sketch 
  sketchUrl="/computacionales-2025-20/sketches/colorWheel.js" 
  containerId="colorWheel"
  styleClass="p5-container-colorWheel"
/>

Te dejo el c√≥digo completo.

ofApp.h

```cpp
#pragma once
#include "ofMain.h"

class Node {
public:
    glm::vec2 position;
    Node* next;

    Node(glm::vec2 pos) : position(pos), next(nullptr) {}
};

class LinkedList {
public:
    Node* head;
    Node* tail;
    int size;

    LinkedList() : head(nullptr), tail(nullptr), size(0) {}

    ~LinkedList() {
        clear();
    }

    void push_back(glm::vec2 pos) {
        Node* newNode = new Node(pos);
        if (head == nullptr) {
            head = tail = newNode;
        }
        else {
            tail->next = newNode;
            tail = newNode;
        }
        size++;
    }

    void pop_back() {
        if (head == nullptr) return;

        if (head == tail) { // Si solo hay un elemento
            delete head;
            head = tail = nullptr;
        }
        else {
            Node* temp = head;
            while (temp->next != tail) {
                temp = temp->next;
            }
            delete tail;
            tail = temp;
            tail->next = nullptr;
        }
        size--;
    }

    void clear() {
        Node* current = head;
        while (current != nullptr) {
            Node* nextNode = current->next;
            delete current;
            current = nextNode;
        }
        head = tail = nullptr;
        size = 0;
    }
};


class ofApp : public ofBaseApp {
public:
    LinkedList snake;
    float backgroundHue;

    void setup();
    void update();
    void draw();
    void keyPressed(int key);
};

```
ofApp.cpp

```cpp
#include "ofApp.h"

//--------------------------------------------------------------
void ofApp::setup() {
    backgroundHue = 0;

    // Inicializa la serpiente con varios nodos en el centro
    for (int i = 0; i < 20; i++) {
        snake.push_back(glm::vec2(ofGetWidth() / 2, ofGetHeight() / 2));
    }
}

//--------------------------------------------------------------
void ofApp::update() {
    if (snake.head == nullptr) return;

    glm::vec2 target = glm::vec2(ofGetMouseX(), ofGetMouseY());
    float interpolationFactor = 0.2;

    Node* current = snake.head;
    while (current != nullptr) {
        // glm::mix(x, y, a)
        // mix performs a linear interpolation x and y using a to weight between them.
		// The value is computed as x * (1 - a) + y * a.
        current->position = glm::mix(glm::vec3(current->position, 0.0f), glm::vec3(target, 0.0f), interpolationFactor);
        target = current->position;
        current = current->next;
    }

    backgroundHue = fmod(backgroundHue + 0.1, 255);
}

//--------------------------------------------------------------
void ofApp::draw() {
    ofColor color1 = ofColor::fromHsb(backgroundHue, 150, 240);
    ofColor color2 = ofColor::fromHsb(fmod(backgroundHue + 128, 255), 150, 240);
    ofBackgroundGradient(color1, color2, OF_GRADIENT_LINEAR);

    if (snake.head == nullptr) return;

    ofMesh mesh;
    mesh.setMode(OF_PRIMITIVE_LINE_STRIP);
    Node* current = snake.head;
    int index = 0;

    while (current) {
        float hue = ofMap(index++, 0, snake.size - 1, 0, 255);
        mesh.addColor(ofColor::fromHsb(hue, 200, 255));
        mesh.addVertex(glm::vec3(current->position, 0.0f));
        current = current->next;
    }

    ofSetLineWidth(2);
    mesh.draw();

    // C√≠rculos con tama√±o y color variable
    current = snake.head;
    index = 0;
    ofNoFill();
    ofSetLineWidth(2);

    while (current) {
        float hue = ofMap(index, 0, snake.size - 1, 0, 255);
        ofSetColor(ofColor::fromHsb(hue, 220, 255));
        float radius = ofMap(index++, 0, snake.size - 1, 20, 5);
        ofDrawCircle(current->position.x, current->position.y, radius);
        current = current->next;
    }
}

//--------------------------------------------------------------
void ofApp::keyPressed(int key) {
    if (key == 'c') {
        snake.clear();
    }
    else if (key == 'a') {
        snake.push_back(glm::vec2(ofRandomWidth(), ofRandomHeight()));
    }
    else if (key == 'r') {
        snake.pop_back();
    }
    else if (key == 's') {
        ofSaveFrame();
    }
}
```

üì§ **Entrega**: responde las preguntas que te voy dejando en el enunciado. 
Estas preguntas buscan que leas m√°s lentamente el c√≥digo y entiendas lo que
haces.
